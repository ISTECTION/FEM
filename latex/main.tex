\documentclass[12pt,a4paper]{article}
\usepackage[left=20mm,top=20mm,total={170mm,257mm}]{geometry}

%  - documentation minted -
% https://tools.ietf.org/doc/texlive-doc/latex/minted/minted.pdf
% - documentation tcolorbox -
% https://ctan.math.washington.edu/tex-archive/macros/latex/contrib/tcolorbox/tcolorbox.pdf


\usepackage{styles/preamble}
\usepackage{minted}                 % Для вставок с кодом
\usepackage{mathtools}              % Для математических формул
\usepackage{amsmath}

\usepackage[dvipsnames]{xcolor}
\setmainfont[Scale=1.0]{Noto Sans}  % Connect font

\usemintedstyle{xcode}                                  % Стиль кода пакета minted
\definecolor{mintedbackground}{rgb}{0.98,0.98,0.98}     % Color minted background

% Property for C++ code
\newmintedfile[cppcode]{cpp}{
    bgcolor=mintedbackground,   % Background
    fontfamily=tt,              % Font
    linenos=true,               % Numbering
    numberblanklines=true,      %
    numbersep=3pt,              % Separator number
    gobble=0,                   % Сожрать первые символы каждой строки
    frame=leftline,             % Left line
    framerule=0.2pt,            % Ширина линии
    framesep=5pt,               % Отступ от разделителя
    funcnamehighlighting=true,  %
    tabsize=4,                  % Количество пробелов табуляции
    mathescape=true,            % Включение математических формул
    showspaces=false,           % Показывать пробелы
    showtabs=false,             % Показывать табуляции
    baselinestretch=1.1,        % Расстояние между строчками
    breaklines                  % Перенос строк
}


\definecolor{background-gray}{gray}{0.625}
\usepackage[most]{tcolorbox}    % для управления цветом
\newtcolorbox{myquote}{
    colback=background-gray,
    coltext=white,
    grow to right by=-1mm,
    grow to left by=-1mm,
    boxrule=-1mm,
    boxsep=0pt
} % настройки области с изменённым фоном

% =================================================
% НАЧАЛО ДОКУМЕНТА
% =================================================
\begin{document}
\import{titlepage/}{title}

\section{Условие задачи}                % Условие задачи
\subsection*{Формулировка задачи}       % Формулировка задачи

МКЭ для двумерной краевой задачи для эллиптического
уравнения в декартовой системе координат. Базисные
функции линейные на треугольниках. Краевые условия
всех ти-пов. Коэффициент разложить по линейным
базисным функциям. Матрицу СЛАУ генери-ровать
в разреженном строчном формате. Для решения
СЛАУ использовать МСГ или ЛОС с неполной
факторизацией.

\subsection*{Постановка задачи}

Эллиптическая краевая задача для функции \textit{u}
определяется дифференциальным уравнением

\[ -div( \lambda grad u) + \gamma u = f \]

\noindent заданным в некоторой области $\Omega$ с границей
$S=S_1 \cup S_2 \cup S_3$ и краевыми условиями:

\[ u \vert_{S_1} = u_g \]
\[ \lambda \frac{\partial u}{\partial n} \bigg\vert_{S_2} = \theta \]
\[ \lambda \frac{\partial u}{\partial n} \bigg\vert_{S_3}
    + \beta(u \vert_{S_3} - u_{\beta}) = 0 \]

\noindent В декартовой системе координат {x,y} это
уравнение может быть записано в виде

\[ -\frac{\partial}{\partial x}
    \left( \lambda \frac{\partial u}{\partial x} \right)
    -\frac{\partial}{\partial y}
    \left( \lambda \frac{\partial u}{\partial y} \right)
    + \gamma u = f \]

\subsection*{Конечноэлементная дискретизация}

Так как для решения задачи используются линейные базисные
функции, то на каждом конечном элементе $\Omega_k$ -
треугольнике эти функции будут совпадать с функциями
$L_1(x,y), L_2(x,y), L_3(x,y)$, такими, что $L_1(x,y)$
равна единице в вершине $(x_1,y_1)$ и нулю во всех остальных
вершинах, $L_2(x,y)$ равна единице в вершине $(x_2,y_2)$
и нулю во всех остальных вершинах, $L_3(x,y)$ равна единице
в вершине $(x_3,y_3)$ и нулю во всех остальных вершинах.
Любая линейная на $\Omega_k$ функция представима в виде
линейной комбинации этих базисных линейных функций,
коэффициентами будут значения функции в каждой из вершин
треугольника $\Omega_k$. Таким образом, на каждом конечном
элементе нам понадобятся три узла – вершины треугольника.

\[ \psi_1 = L_1(x,y) \]
\[ \psi_2 = L_2(x,y) \]
\[ \psi_3 = L_3(x,y) \]
\newpage

\noindent Учитывая построение \textit{L-функций},
получаем следующие соотношения:

\begin{equation*}
    \begin{cases}
        L_1 + L_2 + L_3 = 1          \\
        L_1x_1 + L_2x_2 + L_3x_3 = x \\
        L_1y_1 + L_2y_2 + L_3y_3 = y
    \end{cases}
\end{equation*}

\noindent Т.e. имеем систему:
\renewcommand{\arraystretch}{1.25}
\begin{equation*}
    \begin{pmatrix}
        1   & 1   & 1   \\
        x_1 & x_2 & x_3 \\
        y_1 & y_2 & y_3
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        L_1 \\
        L_2 \\
        L_3
    \end{pmatrix}
    =
    \begin{pmatrix}
        1 \\
        x \\
        y
    \end{pmatrix}
\end{equation*}
\renewcommand{\arraystretch}{1.0}

\noindent Отсюда находим коэффициенты
линейных функций $L_1(x,y), L_2(x,y), L_3(x,y)$
\[ L_i = a_0^i + a_1^ix + a_2^iy, i = \overline{1,3} \]

\renewcommand{\arraystretch}{1.25}
\begin{equation*}
    \begin{pmatrix}
        \alpha_0^1 & \alpha_1^1 & \alpha_2^1 \\
        \alpha_0^2 & \alpha_1^2 & \alpha_2^2 \\
        \alpha_0^3 & \alpha_1^3 & \alpha_2^3
    \end{pmatrix}
    =
    D^{-1}
    =
    {\begin{pmatrix}
        1   & 1   & 1   \\
        x_1 & x_2 & x_3 \\
        y_1 & y_2 & y_3
    \end{pmatrix}}^{-1}
\end{equation*}
\renewcommand{\arraystretch}{1.0}

\renewcommand{\arraystretch}{1.25}
\begin{equation*}
    D^{-1} = \frac{1}{\vert det D \vert}
    \begin{pmatrix}
        x_2y_3-x_3y_2 & y_2-y_3 & x_3-x_2 \\
        x_3y_1-x_1y_3 & y_3-y_1 & x_1-x_3 \\
        x_1y_2-x_2y_1 & y_1-y_2 & x_2-x_1
    \end{pmatrix}
\end{equation*}
\renewcommand{\arraystretch}{1.0}

\subsection*{Переход к локальным матрицам}

Чтобы получить выражения для локальных
матриц жёсткости G и массы M каждого
конечного элемента $\Omega_K$, перейдём
к решению локальной задачи на каждом
конечном элементе. Полученное уравнение
для области $\Omega$ представим в виде
суммы интегралов по областям $\Omega_k$
без учёта краевых условий. Тогда на
каждом конечном элементе будем решать
локальную задачу построения матриц
жёсткости, массы и вектора правой части.

$$
\int \limits_{\Omega_k} \lambda
\left(
    \frac{\partial \psi_j}{\partial x}
    \frac{\partial \psi_i}{\partial x}
    +
    \frac{\partial \psi_j}{\partial y}
    \frac{\partial \psi_i}{\partial y}
\right) dxdy
+
\int \limits_{\Omega_k} \gamma \psi_j \psi_i dsdy
=
\int \limits_{\Omega_k} f \psi_i dxdy
$$

\noindent Локальная матрица будет представлять
собой сумму матриц жёсткости и массы и будет
иметь размерность $3 \times 3$ (по числу
узлов на конечном элементе)

\subsection*{Построение матрицы массы}

\begin{eqnarray*}
M_{ij} =
    \int \limits_{\Omega_m} \gamma Y_iY_j d\Omega_m =
    \Big \vert \gamma = Y_1\gamma_1
                      + Y_2\gamma_2
                      + Y_3\gamma_3
    \Big \vert
    =
    \int \limits_{\Omega_m}
        \left(
            Y_1\gamma_1
          + Y_2\gamma_2
          + Y_3\gamma_3
        \right) Y_i Y_j d \Omega_m = \\ =
    \gamma_1 \int \limits_{\Omega_m} Y_1 Y_i Y_j d \Omega_m +
    \gamma_2 \int \limits_{\Omega_m} Y_2 Y_i Y_j d \Omega_m +
    \gamma_3 \int \limits_{\Omega_m} Y_3 Y_i Y_j d \Omega_m = \\ =
    \gamma_1 \int \limits_{\Omega_m} L_1 L_i L_j d \Omega_m +
    \gamma_2 \int \limits_{\Omega_m} L_2 L_i L_j d \Omega_m +
    \gamma_3 \int \limits_{\Omega_m} L_3 L_i L_j d \Omega_m
\end{eqnarray*}

\subsection*{Построение матрицы жёсткости}

Рассмотрим первый член в выражении для k-го конечного
эдемента:

$$
\int \limits_{\Omega_k} \lambda
    \left(
        \frac{\partial \psi_j}{\partial x}
        \frac{\partial \psi_i}{\partial x}
        +
        \frac{\partial \psi_j}{\partial y}
        \frac{\partial \psi_i}{\partial y}
        dxdy
    \right)
$$

$$
B_{i,j}=(\alpha_1^i \alpha_1^j + \alpha_2^i \alpha_2^j)
    \frac{\big \vert det D \big \vert}{2}
    \hspace{15pt} i,j=\overline{0,2}
$$

\subsection*{Построение вектора правой части}

Рассмотрим правую часть выражения для k-го конечного элемента:

$$
\int \limits_{\Omega_k} f \psi_i dxdy
$$

\noindent представим $f$ в виде $f_1 L_1 + f_2 L_2 + f_3 L_3$, где
$f_i$ - значения в вершинах треугольника. Получим:

$$
\int \limits_{\Omega_k} f_q L_q L_i dxdy =
    f_q \int \limits_{\Omega_k} L_q L_i d \Omega_k
$$

\noindent Таким образом:
$$
G_i = \sum \limits_{q=1}^{3}
    f_q \int \limits_{\Omega_k} L_q L_i d\Omega_k
    \hspace{15pt} i=\overline{0,2}
$$

\subsection*{Сборка глобальной матрицы и глобального вектора}

При формировании глобальной матрицы из локальных,
полученных суммированием соответствующих матриц
массы и жесткости, учитываем соответствие локальной
и глобальной нумераций каждого конечного элемента.
Глобальная нумерация каждого конечного элемента
однозначно определяет позиции вклада его локальной м
атрицы в глобальную. Поэтому, зная глобальные
номера соответствующих узлов конечного элемента,
определяем и то, какие элементы глобальной матрицы
изменятся при учете текущего конечного элемента.
Аналогичным образом определяется вклад локального
вектора правой части в глобальный. При учете
текущего локального вектора изменятся те элементы
глобального вектора правой части, номера которых
совпадают с глобальными номерами узлов, присутствующих
в этом конечном элементе.

\subsection*{Учёт первых краевых условий}

Для учета первых краевых условий, в глобальной матрице
и глобальном векторе находим соответствующую глобальному
номеру краевого узла строку и зануляем всё кроме
диагонального элемента, которому присваиваем 1, а вместо
элемента с таким номером в векторе правой части - значение
краевого условия, заданное в исходной задаче.


\subsection*{Учёт вторых и трeтьих краевых условий}

Рассмотрим краевые условия второго и третьего рода:
$$
    \lambda \frac{\partial u}{\partial n}
    \bigg\vert_{S_2} = \theta
$$

$$
    \lambda \frac{\partial u}{\partial n}
    \bigg\vert_{S_3} +
    \beta(u \vert_{S_3} - u_{\beta}) = 0
$$

\noindent Отсюда получаем, что для учёта краевых условий
необходимо вычислить интегралы:

$$
    \int \limits_{S_2} \theta \psi_j dxdy,          \hspace{25pt}
    \int \limits_{S_3} \beta u_{\beta} \psi_j dxdy, \hspace{25pt}
    \int \limits_{S_3} \beta \psi_i \psi_j dxdy
$$

\noindent Краевые условия второго и третьего рода задаются
на рёбрах, т.е. определяются двумя узлами, лежащими на
ребру. Будем считать, что параметр $\beta$ на $S_3$
постоянен, тогда параметр $г_{\beta}$ будем
раскладывать по двум базисным функциям,
определённым на этом ребре:
$$ u_{\beta} = u_{\beta 1} \phi_1 + u_{\beta 2} \phi_2 $$

\noindent где $\phi_i, \hspace{5pt} i=\overline{0,1}$

- локально занумерованные линейные базисные функции,
которые имеют также свои глобальные номера во всей
расчетной области, а $u_{\beta i}$ - значение функции
$u_{\beta}$ в узлах ребра. \\

\noindent Аналогично поступаем и при учете вторых
краевых условий, раскладывая по базису ребра функцию
$\theta = \theta_0 \phi_0 + theta_1 \phi_1$.

\noindent Тогда приведенные выше интегралы примут вид:

$$ I_1 = \int \limits_{S_2} (\theta_0 \phi_0 + \theta_1 \phi_1) \phi_i dxdy $$
$$ I_2 = \beta \int \limits_{S_3} (u_{\beta 1} \phi_0 + u_{\beta 2} \phi_1) \phi_i dxdy $$
$$ I_3 = \beta \int \limits_{S_3} \phi_i \phi_j dxdy $$

\noindent Фактически, решая задачу учета краевых условий второго
и третьего рода, мы переходим к решению одномерной
задачи на ребре для того, чтобы занести соответствующие
результаты в глобальную матрицу и вектор. \\

\noindent Базисными функциями ребра являются две
ненулевые на данном ребре базисные функции из
$\phi_i, \hspace{5pt} i=\overline{0,1}$
конечного элемента. \\

\noindent Для учёта вклада вторых и третьих краевых условий
рассчитываются 2 матрицы $2 \times 2$. \\

\noindent Игтегралы $I_1, I_2, I_3$ будем вычислять по формуле:
$$
    \int \limits_Г (L_i)^{v_i} (L_j)^{v_j} dS =
    \frac{v_i ! v_j !}{(v_i + v_j + 1)!} mes \Gamma,
    \hspace{5pt} i \neq j
$$

\noindent где $mes \Gamma$ длина ребра. При этом независимо
от того, что на каждом из ребер присутствуют свои функции,
интегралы, посчитанные по приведенным выше формулам,
будут равны.

\renewcommand{\arraystretch}{1.25}
\begin{equation*}
    I_1 =
    \begin{pmatrix}
        \int \limits_{S_2} L_1L_1dxdy & \int \limits_{S_2} L_1L_2dxdy \\
        \int \limits_{S_2} L_2L_1dxdy & \int \limits_{S_2} L_2L_2dxdy
    \end{pmatrix}
    \begin{pmatrix}
        \theta_1 \\
        \theta_2
    \end{pmatrix}
    = \frac{1}{6} mes S_2
    \begin{pmatrix}
        2 & 1 \\
        1 & 2
    \end{pmatrix}
    \begin{pmatrix}
        \theta_1 \\
        \theta_2
    \end{pmatrix}
\end{equation*}
\renewcommand{\arraystretch}{1.0}

\noindent Этот вектор поправок в правую
часть позволяет учесть не только вторые
краевые условия, но и часть
$\beta u_{\beta}$ из третьих.
Осталось рассмотреть матрицу
поправок в левую часть:
$$
I_3 = \beta \int \limits_{S_3}
\phi_i \phi_j dxdy
$$

\noindent Очевидно, что получится та же
матрица, только не умноженная на вектор
констант.

$$
I_3 = \frac{1}{6} mes S_3
\begin{pmatrix}
    2 & 1 \\
    1 & 2
\end{pmatrix}
$$

\noindent Добавляя эту матрицу в левую часть,
на места соответствующие номерам узлов,
получаем учет третьих краевых условий.


\section{Текст программы}
\begin{myquote}
    \begin{center}
        \textbf{main.cpp}
    \end{center}
\end{myquote}
\cppcode{../src/main.cpp}

\begin{myquote}
    \begin{center}
        \textbf{FEM.hpp}
    \end{center}
\end{myquote}

\begin{minted}[
    bgcolor=mintedbackground,
    fontfamily=tt,
    linenos=true,
    numberblanklines=true,
    numbersep=3pt,
    gobble=0,
    frame=leftline,
    framerule=0.2pt,
    framesep=5pt,
    funcnamehighlighting=true
    tabsize=4,
    mathescape=true,
    showspaces=false,
    showtabs=false,
    baselinestretch=1.1,
    breaklines
]{c++}
#ifndef _FEM_HPP_
#define _FEM_HPP_
#include "utils/lightweight.hpp"
#include "utils/overload.hpp"
#include "Function.hpp"
#include "Logger.hpp"
#include "Union.hpp"

#include <algorithm>
#include <cmath>
#include <set>

#define FIRST_BOUNDARY_COND  1
#define SECOND_BOUNDARY_COND 2
#define THIRD_BOUNDARY_COND  3

class FEM
{
private:
    Union::Param _size;

    std::vector<Union::XY>       nodes;
    std::vector<Union::Element>  elems;
    std::vector<Union::Boundary> boundarys;
    std::vector<Union::Material> materials;

    std::vector<double> gb;
    std::vector<double> gg;
    std::vector<double> di;
    std::vector<size_t> ig;
    std::vector<size_t> jg;

public:
    FEM(std::filesystem::path _path) {
        assert(readFile(_path));
        portrait(true);
        global();
        boundaryСondition();
    }
    ~FEM() { }

    void printAll()    const;
    void printSparse() const;

    void writeFile(
        const std::filesystem::path&,
        const double,
        const size_t
    ) const;

private:
    void global();

    template<size_t N, typename _Struct>
    void loc_A_to_global(
        const std::array<std::array<double, N>, N>&,
        const _Struct&
    );

    template<size_t N, typename _Struct>
    void loc_b_to_global(const std::array<double, N>&, const _Struct& );

    array::xxx localA(const std::array<Union::XY, 3>&, size_t) const;
    array::x   buildF(const std::array<Union::XY, 3>&, size_t) const;

    array::xxx G(const std::array<Union::XY, 3>&, size_t) const;
    array::xxx M(const std::array<Union::XY, 3>&, size_t) const;

    bool readFile(const std::filesystem::path&  );
    void portrait(const bool isWriteList = false);

    void boundaryСondition();
    void first (const Union::Boundary& bound);
    void second(const Union::Boundary& bound);
    void third (const Union::Boundary& bound);

    void resize();
};

void FEM::global() {

    std::array<Union::XY, 3> coords;

    for (size_t i = 0; i < _size.elems; i++) {
        for (size_t j = 0; j < 3; j++) {
            size_t point = elems[i].nodeIdx[j];
            coords[j].x = nodes[point].x;
            coords[j].y = nodes[point].y;
        }
        array::x   local_b = buildF(coords, elems[i].area);
        array::xxx local_A = localA(coords, elems[i].area);

        pretty(local_A);

        loc_A_to_global<3>(local_A, elems[i]);
        loc_b_to_global<3>(local_b, elems[i]);
    }
}

void FEM::boundaryСondition() {
    using namespace ::Log;

    for (size_t _count = 0; _count < _size.conds; _count++) {

        switch (boundarys[_count].cond)
        {
            case FIRST_BOUNDARY_COND:
                first(boundarys[_count]);
                break;
            case SECOND_BOUNDARY_COND:
                second(boundarys[_count]);
                break;
            case THIRD_BOUNDARY_COND:
                third(boundarys[_count]);
                break;
            default:
                Logger::append(getLog("There is no such condition"));
        }
    }
}

void FEM::first(const Union::Boundary& bound) {
    di[bound.nodeIdx[0]] = { 1 };
    di[bound.nodeIdx[1]] = { 1 };

    for (size_t i = 0; i < 2; i++)
        gb[bound.nodeIdx[i]] =
            Function::firstBound({
                nodes[bound.nodeIdx[i]].x,
                nodes[bound.nodeIdx[i]].y
            }, bound.type);

    for (size_t k = 0; k < 2; k++) {
        size_t node = bound.nodeIdx[k];
        for (size_t i = ig[node]; i < ig[node + 1]; i++) {
            gb[jg[i]] -= gg[i] * gb[node];
            gg[i] = 0;
        }

        for(size_t i = node + 1; i < _size.nodes; i++) {
            size_t lbeg = ig[i];
            size_t lend = ig[i + 1];
            for(int p = lbeg; p < lend; p++) {
                if(jg[p] == node) {
                    gb[i] -= gg[p] * gb[node];
                    gg[p] = 0;
                }
            }
        }
    }
}

void FEM::second(const Union::Boundary& bound) {

    std::array<Union::XY, 2>
        coord_borders = {
            nodes[bound.nodeIdx[0]],
            nodes[bound.nodeIdx[1]]
        };

    double _koef = edgeLength(coord_borders) / 6;

    std::array<double, 2> corr_b;
    for (size_t i = 0; i < 2; i++)
        corr_b[i] = _koef * (
            2 * Function::secondBound({
                    nodes[bound.nodeIdx[i]].x,
                    nodes[bound.nodeIdx[i]].y
                }, bound.type) +
                Function::secondBound({
                    nodes[bound.nodeIdx[1 - i]].x,
                    nodes[bound.nodeIdx[1 - i]].y
                }, bound.type)
            );

    loc_b_to_global<2>(corr_b, bound);
}

void FEM::third(const Union::Boundary& bound) {

    std::array<Union::XY, 2> coord_borders = {
        nodes[bound.nodeIdx[0]],
        nodes[bound.nodeIdx[1]]
    };

    double _koef =
        materials[bound.area].betta *
        edgeLength(coord_borders) / 6;


    std::array<std::array<double, 2>, 2> corr_a;

    std::array<double, 2> corr_b;
    for (size_t i = 0; i < 2; i++) {

        corr_b[i] = _koef * (
            2 * Function::thirdBound({
                    nodes[bound.nodeIdx[i]].x,
                    nodes[bound.nodeIdx[i]].y
                }, bound.type) +
                Function::thirdBound({
                    nodes[bound.nodeIdx[1 - i]].x,
                    nodes[bound.nodeIdx[1 - i]].y
                }, bound.type)
            );

        for (size_t j = 0; j < 2; j++) {
            corr_a[i][j] =
                (i == j) ? (2 * _koef) :
                           (    _koef) ;
        }
    }
    loc_b_to_global<2>(corr_b, bound);
    loc_A_to_global<2>(corr_a, bound);
}
template<size_t N, typename _Struct>
void FEM::loc_A_to_global(
        const std::array<std::array<double, N>, N>& locA,
        const _Struct& elem) {

    using            ::std::vector;
    using iterator = ::std::vector<size_t>::iterator;

    for (size_t i = 0; i < N; i++) {
        di[elem.nodeIdx[i]] += locA[i][i];

        for (int j = 0; j < i; j++) {
            size_t a = elem.nodeIdx[i];
            size_t b = elem.nodeIdx[j];
            if (a < b) std::swap(a, b);

            if (ig[a + 1] > ig[a]) {
                iterator _beg = jg.begin() + ig[a];
                iterator _end = jg.begin() + ig[a + 1] - ig[0];

                auto _itr = std::lower_bound(_beg, _end, b);
                auto _idx = _itr - jg.begin();
                gg[_idx] += locA[i][j];
            }
        }
    }
}

template<size_t N, typename _Struct>
void FEM::loc_b_to_global(
        const std::array<double, N>& loc_b,
        const _Struct& elem) {

    for (size_t i = 0; i < N; i++)
        gb[elem.nodeIdx[i]]
            += loc_b[i];
}

array::x FEM::buildF(const std::array<Union::XY, 3>& elem, size_t area) const {
    std::array<double, 3> function {
        Function::f(elem[0], area),
        Function::f(elem[1], area),
        Function::f(elem[2], area)
    };

    double det_D = abs(determinant(elem)) / 24;
    return {
        det_D * (2 * function[0] + function[1] + function[2]),
        det_D * (2 * function[1] + function[0] + function[2]),
        det_D * (2 * function[2] + function[0] + function[1]),
    };
}

array::xxx FEM::localA(const std::array<Union::XY, 3>& elem, size_t area) const
    std::array<std::array<double, 3>, 3> G = FEM::G(elem, area);
    std::array<std::array<double, 3>, 3> M = FEM::M(elem, area);
    std::array<std::array<double, 3>, 3> A = G + M;
    return A;

}

array::xxx FEM::G(const std::array<Union::XY, 3>& elem, size_t area) const {
    double det   = abs(determinant(elem));
    double _koef = Function::lambda(area) / (2 * det);

    std::array<std::array<double, 3>, 3> G;
    std::array<std::array<double, 2>, 3> a {

            elem[1].y - elem[2].y,
            elem[2].x - elem[1].x,

            elem[2].y - elem[0].y,
            elem[0].x - elem[2].x,

            elem[0].y - elem[1].y,
            elem[1].x - elem[0].x
    };

    for (int i = 0; i < 3; i++)
    for (int j = 0; j < 3; j++)
        G[i][j] = _koef * (a[i][0] * a[j][0] + a[i][1] * a[j][1]);

    return G;
}

array::xxx FEM::M(const std::array<Union::XY, 3>& elem, size_t area) const {
    double det = abs(determinant(elem));
    double gammaKoef = materials[area].gamma * det / 24;
    std::array<std::array<double, 3>, 3> M;
    for (size_t i = 0; i < 3; i++)
    for (size_t j = 0; j < 3; j++) {
        M[i][j] =
            (i == j) ? (2 * gammaKoef) :
                       (    gammaKoef) ;
    }
    return  M;
}

void FEM::portrait(const bool isWriteList) {

    const size_t N {    _size.nodes     };
    std::vector<std::set<size_t>> list(N);

    for (size_t el = 0; el < _size.elems; el++)
    for (size_t point = 0; point < 3; point++) {
        for (size_t i = point + 1; i < 3; i++) {
            size_t idx1 = { elems[el].nodeIdx[point] };
            size_t idx2 = { elems[el].nodeIdx[  i  ] };
            idx1 > idx2 ?
                list[idx1].insert(idx2) :
                list[idx2].insert(idx1) ;
        }
    }

    for (size_t i = 2; i < ig.size(); i++)
        ig[i] = ig[i - 1] + list[i - 1].size();

    jg.resize(ig[N] - ig[0]);
    gg.resize(ig[N] - ig[0]);

   for (size_t index = 0, i = 1; i < list.size(); i++)
    for (size_t value : list[i])
        jg[index++] = value;

    if (isWriteList) {
        std::cout << "list: " << '\n';
        for (size_t i = 0; i < list.size(); i++) {
            std::cout << i << ':' << ' ';
            for (size_t j : list[i])
                std::cout << j << ' ';
            std::cout << std::endl;
        }
    }
}

void FEM::printAll() const {
    #define PRINTLINE \
        for (size_t i = 0; i < 20; std::cout << '-', i++);
    #define ENDLINE std::cout << '\n';
    SetConsoleOutputCP(65001);
    PRINTLINE ENDLINE
    std::cout << "PARAMS:         "                 << '\n';
    std::cout << "Size nodes:     " << _size.nodes  << '\n';
    std::cout << "Size element:   " << _size.elems  << '\n';
    std::cout << "Size areas:     " << _size.areas  << '\n';
    std::cout << "Size condition: " << _size.conds  << '\n';
    PRINTLINE ENDLINE
    std::cout << std::setw(4) << "X" << std::setw(4) << "Y" << '\n';
    for (size_t i = 0; i < _size.nodes; i++)
        std::cout << std::setw(4) << nodes[i].x
                  << std::setw(4) << nodes[i].y << '\n';
    PRINTLINE ENDLINE
    std::cout << "Elements: " << '\n';
    for (size_t i = 0; i < _size.elems; i++)
        std::cout << elems[i].nodeIdx[0] << ' '
                  << elems[i].nodeIdx[1] << ' '
                  << elems[i].nodeIdx[2] << " -> area "
                  << elems[i].area       << '\n';
    PRINTLINE ENDLINE
    std::cout << "Areas: " << '\n';
    for (size_t i = 0; i < _size.areas; i++) {
        std::cout << "\u03B3 = " << materials[i].gamma  << ',' << ' '
                  << "\u03B2 = " << materials[i].betta
                  << " -> area " << i << '\n';
    }
    PRINTLINE ENDLINE
    std::cout << "Borders: " << '\n';
    for (size_t i = 0; i < _size.conds; i++)
        std::cout << boundarys[i].area       << ' '
                  << boundarys[i].nodeIdx[0] << ' '
                  << boundarys[i].nodeIdx[1] << ' '
                  << boundarys[i].cond       << ' '
                  << boundarys[i].type       << ' ' << '\n';
    PRINTLINE ENDLINE
    #undef PRINTLINE
    #undef ENDLINE
}

void FEM::printSparse() const {
    #define PRINTLINE \
        for (size_t i = 0; i < 20; std::cout << '-', i++); \
        std::cout << '\n';

    PRINTLINE
    std::cout << "ig: "; print(ig);
    std::cout << "jg: "; print(jg);
    std::cout << "di: "; print(di);
    std::cout << "gg: "; print(gg);
    PRINTLINE

    #undef PRINTLINE
}

bool FEM::readFile(const std::filesystem::path& path) {
    using namespace ::Log;
    bool isError { true };

    std::ifstream fin(path / "params.txt");
    isError &= is_open(fin, getLog("Error - params.txt"));
    fin >> _size.nodes
        >> _size.elems
        >> _size.areas
        >> _size.conds;
    fin.close();

    resize();
    std::fill_n(ig.begin(), 2, 0);

    fin.open(path / "nodes.txt");
    isError &= is_open(fin, getLog("Error - nodes.txt"));
    for (size_t i = 0; i < _size.nodes; i++)
		fin >> nodes[i].x >> nodes[i].y;
    fin.close();

    fin.open(path / "elems.txt");
    isError &= is_open(fin, getLog("Error - elems.txt"));
	for (size_t i = 0; i < _size.elems; i++) {
		fin >> elems[i].nodeIdx[0]
            >> elems[i].nodeIdx[1]
            >> elems[i].nodeIdx[2];
    }
    fin.close();

    fin.open(path / "areas.txt");
    isError &= is_open(fin, getLog("Error - areas.txt"));
    for (size_t i = 0; i < _size.areas; i++)
        fin >> materials[i].gamma
            >> materials[i].betta;

    for (size_t i = 0; i < _size.elems; i++)
        fin >> elems[i].area;
    fin.close();

    fin.open(path / "bords.txt");
    isError &= is_open(fin, getLog("Error - bords.txt"));
    for (size_t i = 0; i < _size.conds; i++)
        fin >> boundarys[i].area
            >> boundarys[i].nodeIdx[0]
            >> boundarys[i].nodeIdx[1]
            >> boundarys[i].cond
            >> boundarys[i].type;
    fin.close();
    return isError;
}

void FEM::writeFile(
        const std::filesystem::path& _path,
        const double _eps,
        const size_t _max_iter) const {

    std::filesystem::create_directories(_path);
    bool is_dir = std::filesystem::is_directory(_path);

    using namespace ::Log;
    if (not is_dir) assert(
        Logger::append(getLog("Error - create directory"))
    );

    std::ofstream fout(_path / "kuslau.txt");
    fout << _size.nodes             << '\n';
    fout << std::scientific << _eps << '\n';
    fout << _max_iter;
    fout.close();

    Output::write(_path / "gg.txt", gg, { 14, ' ' });
    Output::write(_path / "di.txt", di, { 14, ' ' });
    Output::write(_path / "jg.txt", jg);
    Output::write(_path / "ig.txt", ig);
    Output::write(_path / "gb.txt", gb);
}

void FEM::resize() {
    nodes.    resize(  _size.nodes  );
    elems.    resize(  _size.elems  );
    boundarys.resize(  _size.conds  );
    materials.resize(  _size.areas  );

    gb.resize(  _size.nodes  );
    di.resize(  _size.nodes  );
    ig.resize(_size.nodes + 1);
}

#undef FIRST_BOUNDARY_COND
#undef SECOND_BOUNDARY_COND
#undef THIRD_BOUNDARY_COND
#endif /// _FEM_HPP_
\end{minted}






\section{Тестирование}
\section{Выводы}

\end{document}




% ~~~~~~~~ INFO ~~~~~~~~ %

% Добавления кода в одну строку
% \inputminted[
% baselinestretch=1.0,
% mathescape=true,
% breaklines,
% linenos
% ]{cpp}{../src/main.cpp}

% Примитивное добавление кода
% \begin{minted}[linenos,mathescape=true,baselinestretch=1.0]{c++}
% #include "argparse/argparse.hpp"
% #include "timer/cxxtimer.hpp"
% #include "LOS/LOS.hpp"
% #include "FEM.hpp"

% int main(int argc, char* argv[]) {
%     using namespace ::Log;
%     using ::std::chrono::milliseconds;

%     argparse::ArgumentParser program("FEM", "1.0.0");
%     program.add_argument("-i", "--input" ).required().help("path to input files" );
%     program.add_argument("-o", "--output").required().help("path to output files");

%     try {
%         program.parse_args(argc, argv);

%         cxxtimer::Timer timer(true);
%         FEM fem      (program.get<std::string>("-i"));
%         fem.writeFile(program.get<std::string>("-o"), 1E-14, 10000);
%         LOS<double> l(program.get<std::string>("-o"));
%         l.solve(Cond::HOLLESKY, true);
%         timer.stop();

%         l.printX();

%         std::cout << '\n' << "Milliseconds: "
%                 << timer.count<milliseconds>() << '\n';
%         fem.printAll();
%         fem.printSparse();
%     }
%     catch(const std::runtime_error& err) {
%         Logger::append(getLog("argc != 3 (FEM -i input -o output)"));
%         std::cerr << err.what();
%         std::cerr << program;
%         std::exit(1);
%     }
%     return 0;
% }
% \end{minted}